# Configuration for function skeleton generation from problem descriptions
# This stage reads generated algorithm problems and produces Python function skeletons
# with proper signatures, type hints, and Google-style docstrings.

model_config: "model.yaml"

io:
  # Input source configuration
  source:
    mode: "fim"  # Options: "fim" or "l2r"
    
    # Directory mapping for different sources
    dir_map:
      fim: "data/generated/problems_desc/fim"
      l2r: "data/generated/problems_desc/l2r"
    
    # Input file name (automatically adjusted based on mode)
    file_name_map:
      fim: "fim_results.jsonl"
      l2r: "l2r_results.jsonl"
    
    # Key to extract problem text from input JSONL
    problem_text_key: "problem_description"
  
  # Output configuration
  out_dir_map:
    fim: "data/generated/func_skeletons/fim"
    l2r: "data/generated/func_skeletons/l2r"
  
  out_file_name: "skeletons.jsonl"
  hash_table_name: "hash_table.txt"

api:
  concurrency:
    max_concurrent_requests: 5

skeleton:
  # Sampling parameters for skeleton generation
  temperature: 0.7
  top_p: 0.95
  max_tokens: 512
  stop: ["\n\nExample", "\n\n---"]  # Stop before generating additional examples
  
  # Batch writing configuration
  batch_write_size: 50
  
  # Number of samples to process (null means process all available)
  num_samples: null

prompts:
  skeleton:
    template: |
      You are an expert Python algorithmic function writer.
      Your task is to read an algorithm problem description and generate a function definition skeleton that includes:

      - A meaningful, descriptive function name in snake_case.
      - Appropriate parameters inferred from the problem.
      - A detailed, structured Python docstring describing the function's purpose, parameters, and return value.

      Requirements:
      - Follow PEP8 and Google-style docstring format.
      - The docstring must include:
        * A brief summary (one sentence).
        * A more detailed explanation (1–3 sentences about logic, inputs, and outputs).
        * A clearly formatted Args section with each parameter's name, type, and description.
        * A Returns section describing what the function returns and its type.
      - Do not include the function implementation, only the definition and docstring.
      - Return your answer in plain text Python format.

      Example 1
      Problem:
      Title: Palindrome Checker
      Description: Given a string, determine whether it reads the same forward and backward. Ignore spaces, punctuation, and capitalization.
      Example:
      Input: "A man, a plan, a canal: Panama"
      Output: True
      Hint: Two-pointer technique or string reversal.

      Output:
      def is_palindrome_string(s: str) -> bool:
          """Check if the given string is a palindrome ignoring spaces, punctuation, and capitalization.

          The function normalizes the input string by removing spaces and punctuation,
          converts it to lowercase, and checks if it reads the same forward and backward.

          Args:
              s (str): The input string to check.

          Returns:
              bool: True if the string is a palindrome, False otherwise.
          """

      Example 2
      Problem:
      Title: N-Queens Solver
      Description: Place N queens on an N×N chessboard such that no two queens attack each other. Return all distinct solutions represented as lists of strings.
      Example:
      For N = 4, one valid output is [".Q..", "...Q", "Q...", "..Q."].
      Hint: Backtracking with pruning.

      Output:
      def solve_n_queens(n: int) -> list[list[str]]:
          """Find all valid placements of N queens on an N×N chessboard.

          Uses backtracking to explore all valid configurations ensuring
          no two queens share the same row, column, or diagonal.

          Args:
              n (int): The size of the chessboard and the number of queens to place.

          Returns:
              list[list[str]]: A list of all valid chessboard configurations represented as strings.
          """

      Example 3
      Problem:
      Title: Shortest Path with Obstacle Removal
      Description: Given a 2D grid where 0 represents empty cells and 1 represents obstacles, find the shortest path from the top-left corner to the bottom-right corner, where you can remove at most k obstacles. Return the minimum number of steps required, or -1 if impossible.
      Example:
      Input: grid = [[0,1,0],[0,1,0],[0,0,0]], k = 1
      Output: 5
      Hint: Use BFS with state compression (x, y, remaining_k) and pruning.

      Output:
      def shortest_path_with_obstacle_removal(grid: list[list[int]], k: int) -> int:
          """Compute the shortest path in a grid allowing removal of up to k obstacles.

          Applies breadth-first search (BFS) with state compression (x, y, remaining_k)
          and pruning to find the minimal path length considering obstacle removals.

          Args:
              grid (list[list[int]]): The grid representing obstacles and empty spaces.
              k (int): The maximum number of obstacles that can be removed.

          Returns:
              int: The minimum number of steps required to reach the goal, or -1 if unreachable.
          """

      Example 4
      Problem:
      {{problem}}

      Output:

